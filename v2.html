<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ãŠæ•£æ­©åˆ—è»Š</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸš‚</text></svg>">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; overflow: hidden; touch-action: manipulation; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Hiragino Sans', sans-serif;
    background: #F7F8FC; color: #2D3748;
    display: flex; flex-direction: column;
  }

  /* ===== ãƒ˜ãƒƒãƒ€ãƒ¼ ===== */
  .header {
    padding: 10px 16px; background: #1B365D;
    display: flex; align-items: center; justify-content: space-between;
    flex-shrink: 0; color: #fff;
  }
  .header h1 { font-size: 17px; white-space: nowrap; }
  .header-right { display: flex; align-items: center; gap: 6px; }
  .ble-badge {
    font-size: 11px; padding: 3px 8px; border-radius: 10px;
    background: rgba(255,255,255,0.15); color: #ccc; white-space: nowrap;
  }
  .ble-badge.connected { background: #38A169; color: #fff; }
  .ble-badge.test-mode { background: #D69E2E; color: #fff; }
  .btn-header {
    font-size: 9px; padding: 2px 6px; border: 1px solid rgba(255,255,255,0.3);
    border-radius: 6px; background: transparent; color: #999; cursor: pointer;
  }
  .btn-header.active { background: #D69E2E; border-color: #D69E2E; color: #fff; }
  .btn-settings { font-size: 16px; padding: 0 4px; border: none; background: transparent; color: #aaa; cursor: pointer; }

  /* ===== ãƒ›ãƒ¼ãƒ ç”»é¢: è·¯ç·šå›³ ===== */
  .route-panel {
    flex: 1; overflow-y: auto; padding: 16px 20px;
    display: flex; flex-direction: column;
  }
  .route-list { list-style: none; flex: 1; }
  .route-item {
    display: flex; align-items: center; padding: 4px 0;
    position: relative;
  }
  .route-line {
    display: flex; flex-direction: column; align-items: center;
    width: 32px; flex-shrink: 0;
  }
  .route-line .track { width: 4px; flex: 1; min-height: 14px; background: #CBD5E0; }
  .route-item:first-child .route-line .track:first-child { background: transparent; }
  .route-item:last-child .route-line .track:last-child { background: transparent; }
  .route-dot {
    width: 18px; height: 18px; border-radius: 50%;
    border: 3px solid #CBD5E0; background: #fff; flex-shrink: 0;
  }
  .route-item.passed .route-dot { border-color: #38A169; background: #38A169; }
  .route-item.passed .route-line .track { background: #38A169; }
  .route-item.next .route-dot { border-color: #4299E1; background: #4299E1; animation: pulse 1.5s infinite; }
  .route-item:last-child .route-dot {
    border-color: #E63946; background: #fff; width: 22px; height: 22px; border-width: 4px;
  }
  .route-item:last-child.passed .route-dot { background: #E63946; }
  .route-info { flex: 1; margin-left: 12px; }
  .route-name {
    font-size: 16px; font-weight: 700; color: #2D3748;
  }
  .route-item.passed .route-name { color: #38A169; }
  .route-item:last-child .route-name { color: #E63946; }
  .route-sub { font-size: 11px; color: #A0AEC0; margin-top: 1px; }
  .route-item.passed .route-sub { color: #68D391; }
  /* å¼·åˆ¶é€šéãƒœã‚¿ãƒ³ */
  .btn-arrive {
    padding: 6px 12px; border: none; border-radius: 8px;
    font-size: 12px; font-weight: 700; cursor: pointer;
    flex-shrink: 0; display: none;
  }
  .btn-arrive.show { display: block; }
  .btn-arrive.station { background: #EBF8FF; color: #2B6CB0; }
  .btn-arrive.station:active { background: #4299E1; color: #fff; }
  .btn-arrive.goal { background: linear-gradient(135deg, #F6AD55, #E53E3E); color: #fff; }
  .btn-arrive.goal:active { background: #E53E3E; }

  /* é§…0å€‹æ™‚ */
  .empty-route {
    flex: 1; display: flex; flex-direction: column;
    align-items: center; justify-content: center; text-align: center;
    padding: 20px;
  }
  .empty-route-icon { font-size: 48px; margin-bottom: 12px; }
  .empty-route-title { font-size: 18px; font-weight: 700; color: #1B365D; margin-bottom: 6px; }
  .empty-route-desc { font-size: 13px; color: #718096; line-height: 1.5; margin-bottom: 16px; }
  .empty-route-btn {
    padding: 14px 28px; border: none; border-radius: 12px;
    background: #4299E1; color: #fff; font-size: 16px; font-weight: 700; cursor: pointer;
  }

  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(66,153,225,0.5); }
    50% { box-shadow: 0 0 0 8px rgba(66,153,225,0); }
  }

  /* ===== ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ ===== */
  .progress-section {
    padding: 10px 16px 6px; background: #fff;
    border-top: 1px solid #E2E8F0; flex-shrink: 0; text-align: center;
  }
  .train-track-bar { width: 100%; height: 48px; margin-bottom: 4px; }
  .progress-number {
    font-size: 44px; font-weight: 800; color: #1B365D;
    font-variant-numeric: tabular-nums;
  }
  .progress-remaining { font-size: 12px; color: #A0AEC0; margin-top: 2px; }

  /* ===== ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ===== */
  .controls {
    padding: 10px 16px 14px; display: flex; gap: 10px;
    background: #fff; border-top: 1px solid #E2E8F0; flex-shrink: 0;
  }
  .btn {
    flex: 1; padding: 14px; border: none; border-radius: 10px;
    font-size: 16px; font-weight: 700; cursor: pointer;
  }
  .btn:disabled { opacity: 0.35; cursor: not-allowed; }
  .btn-ble { background: #4299E1; color: #fff; }
  .btn-start { background: #38A169; color: #fff; }
  .btn-stop { background: #E53E3E; color: #fff; }

  /* ===== è¨­å®šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ ===== */
  .settings-overlay {
    display: none; position: fixed; inset: 0; background: #F7F8FC;
    z-index: 4000; flex-direction: column;
  }
  .settings-overlay.show { display: flex; }
  .settings-header {
    padding: 10px 16px; background: #1B365D; color: #fff;
    display: flex; align-items: center; justify-content: space-between; flex-shrink: 0;
  }
  .settings-header h2 { font-size: 16px; }
  .settings-close {
    padding: 6px 12px; border: none; border-radius: 8px;
    background: rgba(255,255,255,0.15); color: #fff; font-size: 13px; cursor: pointer;
  }
  .settings-search {
    display: flex; gap: 8px; padding: 8px 12px;
    background: #fff; border-bottom: 1px solid #E2E8F0; flex-shrink: 0;
  }
  .settings-search input {
    flex: 1; padding: 8px 12px; border: 1px solid #CBD5E0; border-radius: 8px;
    background: #F7F8FC; color: #2D3748; font-size: 14px; outline: none;
  }
  .settings-search input:focus { border-color: #4299E1; }
  .settings-search input::placeholder { color: #A0AEC0; }
  .settings-search button {
    padding: 8px 14px; border: none; border-radius: 8px;
    background: #4299E1; color: #fff; font-size: 13px; font-weight: 600; cursor: pointer;
  }
  .settings-search button:disabled { opacity: 0.4; }

  /* æ¤œç´¢çµæœ */
  .search-results {
    position: absolute; top: 0; left: 0; right: 0;
    background: #fff; z-index: 5000; max-height: 60%; overflow-y: auto; display: none;
  }
  .search-results.show { display: block; }
  .sr-item { padding: 12px 16px; border-bottom: 1px solid #EDF2F7; cursor: pointer; }
  .sr-item:active { background: #EBF8FF; }
  .sr-name { font-size: 14px; color: #2D3748; }
  .sr-addr { font-size: 11px; color: #A0AEC0; margin-top: 2px; }
  .sr-close { padding: 12px; text-align: center; color: #E53E3E; cursor: pointer; font-size: 13px; }

  /* è¨­å®š: åœ°å›³ */
  .settings-map { position: relative; flex: 1; min-height: 150px; }
  .settings-map #map { width: 100%; height: 100%; }
  .map-hint {
    position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
    background: rgba(27,54,93,0.85); color: #fff; padding: 5px 12px;
    border-radius: 14px; font-size: 12px; pointer-events: none; z-index: 1000;
  }

  /* è¨­å®š: é§…ãƒªã‚¹ãƒˆ */
  .settings-stations {
    background: #fff; border-top: 1px solid #E2E8F0;
    max-height: 200px; overflow-y: auto; flex-shrink: 0;
  }
  .settings-stations ul { list-style: none; }
  .ss-item {
    display: flex; align-items: center; padding: 8px 12px;
    border-bottom: 1px solid #F7FAFC;
  }
  .ss-num { font-size: 13px; font-weight: 700; color: #718096; width: 24px; text-align: center; flex-shrink: 0; }
  .ss-name {
    flex: 1; font-size: 14px; font-weight: 600; color: #2D3748;
    margin: 0 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .ss-name-edit {
    flex: 1; font-size: 14px; font-weight: 600; color: #2D3748;
    margin: 0 8px; border: none; border-bottom: 2px solid #4299E1;
    outline: none; background: transparent; padding: 0;
  }
  .ss-badge {
    font-size: 9px; padding: 1px 5px; border-radius: 4px;
    background: #FED7D7; color: #E63946; font-weight: 600; margin-right: 4px;
  }
  .ss-actions { display: flex; gap: 2px; flex-shrink: 0; }
  .ss-btn {
    width: 30px; height: 28px; border: 1px solid #E2E8F0; background: #fff;
    color: #718096; font-size: 13px; cursor: pointer; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
  }
  .ss-btn:active { background: #4299E1; color: #fff; border-color: #4299E1; }
  .ss-btn:disabled { opacity: 0.15; }
  .ss-btn.delete { color: #E53E3E; }
  .ss-btn.delete:active { background: #E53E3E; color: #fff; }
  .settings-add {
    display: flex; align-items: center; justify-content: center; gap: 6px;
    padding: 12px; color: #4299E1; font-size: 14px; font-weight: 600;
    cursor: pointer; border: 2px dashed #CBD5E0; margin: 8px 12px;
    border-radius: 8px;
  }
  .settings-add:active { background: #EBF8FF; border-color: #4299E1; }

  /* ===== é§…åå…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ« ===== */
  .modal-overlay {
    display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4);
    z-index: 6000; align-items: center; justify-content: center;
  }
  .modal-overlay.show { display: flex; }
  .modal {
    background: #fff; border-radius: 16px; padding: 24px; width: 85%;
    max-width: 320px; box-shadow: 0 20px 60px rgba(0,0,0,0.2);
  }
  .modal h3 { font-size: 16px; margin-bottom: 16px; text-align: center; }
  .modal-input {
    width: 100%; padding: 12px; border: 2px solid #E2E8F0; border-radius: 10px;
    font-size: 18px; text-align: center; outline: none;
  }
  .modal-input:focus { border-color: #4299E1; }
  .modal-suffix { text-align: center; font-size: 18px; color: #718096; margin-top: 4px; }
  .modal-buttons { display: flex; gap: 10px; margin-top: 20px; }
  .modal-btn {
    flex: 1; padding: 12px; border: none; border-radius: 10px;
    font-size: 15px; font-weight: 600; cursor: pointer;
  }
  .modal-cancel { background: #EDF2F7; color: #4A5568; }
  .modal-ok { background: #4299E1; color: #fff; }
</style>
</head>
<body>

<!-- ===== ãƒ˜ãƒƒãƒ€ãƒ¼ ===== -->
<div class="header">
  <h1>ğŸš‚ ãŠæ•£æ­©åˆ—è»Š <span style="font-size:9px;font-weight:400;opacity:0.5">v2.4</span></h1>
  <div class="header-right">
    <span class="ble-badge" id="bleBadge">BLEæœªæ¥ç¶š</span>
    <button class="btn-settings" id="btnSettings">&#9881;</button>
    <button class="btn-header" id="btnTest">TEST</button>
  </div>
</div>

<!-- ===== ãƒ›ãƒ¼ãƒ : è·¯ç·šå›³ ===== -->
<div class="route-panel" id="routePanel"></div>

<!-- ===== ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ ===== -->
<div class="progress-section">
  <canvas class="train-track-bar" id="trainCanvas" width="360" height="48"></canvas>
  <div class="progress-number"><span id="progressValue">0.000</span>%</div>
  <div class="progress-remaining" id="progressRemaining"></div>
</div>

<!-- ===== ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ===== -->
<div class="controls">
  <button class="btn btn-ble" id="btnBle">BLEæ¥ç¶š</button>
  <button class="btn btn-start" id="btnStart" disabled>ã—ã‚…ã£ã±ã¤!</button>
</div>

<!-- ===== è¨­å®šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ ===== -->
<div class="settings-overlay" id="settingsOverlay">
  <div class="settings-header">
    <h2>ãƒ«ãƒ¼ãƒˆã›ã£ã¦ã„</h2>
    <button class="settings-close" id="settingsClose">ã¨ã˜ã‚‹</button>
  </div>
  <div class="settings-search">
    <input type="text" id="searchInput" placeholder="å ´æ‰€ã‚’æ¤œç´¢..." enterkeyhint="search">
    <button id="searchBtn">æ¤œç´¢</button>
  </div>
  <div class="settings-map">
    <div class="map-hint" id="mapHint">ã‚¿ãƒƒãƒ—ã—ã¦ ãˆãã‚’ ã¤ã„ã‹</div>
    <div class="search-results" id="searchResults"></div>
    <div id="map"></div>
  </div>
  <div class="settings-stations">
    <ul id="settingsStationList"></ul>
    <div class="settings-add" id="settingsAdd">+ ãˆãã‚’ã¤ã„ã‹</div>
  </div>
</div>

<!-- ===== é§…åãƒ¢ãƒ¼ãƒ€ãƒ« ===== -->
<div class="modal-overlay" id="nameModal">
  <div class="modal">
    <h3>ğŸš‰ ãˆãã®ãªã¾ãˆ</h3>
    <input class="modal-input" id="nameInput" placeholder="ã“ã†ãˆã‚“" maxlength="6" autocomplete="off">
    <div class="modal-suffix">é§…</div>
    <div class="modal-buttons">
      <button class="modal-btn modal-cancel" id="nameCancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button class="modal-btn modal-ok" id="nameOk">OK</button>
    </div>
  </div>
</div>

<script>
const GMAP_API_KEY = 'AIzaSyDnmItjYjosd4qMt63vWkxY2twew-JVRnA';
let gmapReady = false;

function loadGoogleMaps() {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = `https://maps.googleapis.com/maps/api/js?key=${GMAP_API_KEY}&libraries=places&language=ja`;
    s.onload = () => { gmapReady = true; resolve(); };
    s.onerror = () => reject(new Error('Google Maps load failed'));
    document.head.appendChild(s);
  });
}

// Google Mapsã¯è¨­å®šç”»é¢ã‚’é–‹ã„ãŸã¨ãã«åˆæœŸåŒ–ï¼ˆé…å»¶èª­ã¿è¾¼ã¿ï¼‰
let mapInitPromise = null;
function ensureGoogleMaps() {
  if (!mapInitPromise) mapInitPromise = loadGoogleMaps();
  return mapInitPromise;
}

initApp();

function initApp() {
  // ==================== å®šæ•° ====================
  const SERVICE_UUID        = '12345678-1234-1234-1234-123456789abc';
  const CHARACTERISTIC_UUID = '12345678-1234-1234-1234-123456789def';
  const STORAGE_KEY = 'osampo_v2_stations';
  const STATION_ARRIVAL_RADIUS = 30;
  const GOAL_RADIUS = 10;

  // ==================== çŠ¶æ…‹ ====================
  let bleDevice = null, bleCharacteristic = null;
  let watchId = null, isRunning = false, testMode = false;
  let wakeLock = null;
  let stations = [];
  let startDistance = null;
  let maxProgress = 0;
  let lastSentProgress = -1;
  let nextStationIndex = 0;
  let passedStations = [];
  let pendingStationLatLng = null;

  // è¨­å®šç”»é¢ç”¨
  let map = null, placesService = null;
  let stationMarkers = [], routeLine = null, currentMarker = null;

  // ==================== DOM ====================
  const $ = id => document.getElementById(id);
  const $bleBadge = $('bleBadge'), $btnBle = $('btnBle'), $btnTest = $('btnTest');
  const $btnStart = $('btnStart'), $btnSettings = $('btnSettings');
  const $progressValue = $('progressValue'), $progressRemaining = $('progressRemaining');
  const $routePanel = $('routePanel');
  const $settingsOverlay = $('settingsOverlay'), $settingsClose = $('settingsClose');
  const $searchInput = $('searchInput'), $searchBtn = $('searchBtn'), $searchResults = $('searchResults');
  const $settingsStationList = $('settingsStationList'), $settingsAdd = $('settingsAdd');
  const $mapHint = $('mapHint');
  const $nameModal = $('nameModal'), $nameInput = $('nameInput');
  const $nameCancel = $('nameCancel'), $nameOk = $('nameOk');
  const trainCanvas = $('trainCanvas');

  // ==================== é§…ãƒ‡ãƒ¼ã‚¿ ====================
  function genId() { return Date.now().toString(36) + Math.random().toString(36).slice(2, 6); }
  function saveStations() { localStorage.setItem(STORAGE_KEY, JSON.stringify(stations)); }
  function loadStations() {
    try {
      const d = JSON.parse(localStorage.getItem(STORAGE_KEY));
      if (Array.isArray(d) && d.length > 0) stations = d;
    } catch(e) {}
  }
  function addStation(name, lat, lng) {
    stations.push({ id: genId(), name, lat, lng });
    saveStations(); renderAll();
  }
  function removeStation(id) {
    stations = stations.filter(s => s.id !== id);
    saveStations(); renderAll();
  }
  function renameStation(id, newName) {
    const s = stations.find(s => s.id === id);
    if (s) { s.name = newName; saveStations(); renderAll(); }
  }
  function moveStation(fromIdx, toIdx) {
    if (toIdx < 0 || toIdx >= stations.length) return;
    const [item] = stations.splice(fromIdx, 1);
    stations.splice(toIdx, 0, item);
    saveStations(); renderAll();
  }

  function renderAll() {
    renderRoute();
    renderSettingsStations();
    updateMap();
    updateStartButton();
  }

  // ==================== ãƒ›ãƒ¼ãƒ : è·¯ç·šå›³æç”» ====================
  function renderRoute() {
    $routePanel.innerHTML = '';

    if (stations.length === 0) {
      $routePanel.innerHTML = `
        <div class="empty-route">
          <div class="empty-route-icon">ğŸš‚</div>
          <div class="empty-route-title">ãƒ«ãƒ¼ãƒˆã‚’ã¤ãã‚ã†ï¼</div>
          <div class="empty-route-desc">ãˆãã‚’ã›ã£ã¦ã„ã—ã¦<br>ãŠã•ã‚“ã½ã§ã‚“ã—ã‚ƒã‚’ ã¯ã—ã‚‰ã›ã‚ˆã†</div>
          <button class="empty-route-btn" id="emptySetupBtn">ã›ã£ã¦ã„ã™ã‚‹</button>
        </div>
      `;
      $('emptySetupBtn').addEventListener('click', openSettings);
      return;
    }

    const ul = document.createElement('ul');
    ul.className = 'route-list';

    stations.forEach((s, i) => {
      const li = document.createElement('li');
      li.className = 'route-item';
      const isLast = i === stations.length - 1;
      const isPassed = isRunning && passedStations[i];
      const isNext = isRunning && i === nextStationIndex && !passedStations[i];

      if (isPassed) li.classList.add('passed');
      if (isNext) li.classList.add('next');

      const distText = i > 0
        ? formatDist(haversineDistance(stations[i-1].lat, stations[i-1].lng, s.lat, s.lng))
        : '';

      // å¼·åˆ¶é€šéãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ¡ä»¶
      const showArrive = isRunning && !isPassed && !testMode;
      const btnClass = isLast ? 'goal' : 'station';
      const btnText = isLast ? 'ã‚´ãƒ¼ãƒ«!' : 'ã¨ã†ã¡ã‚ƒã';

      li.innerHTML = `
        <div class="route-line">
          <div class="track"></div>
          <div class="route-dot"></div>
          <div class="track"></div>
        </div>
        <div class="route-info">
          <div class="route-name">${s.name}é§…</div>
          <div class="route-sub">${isPassed ? 'ã¤ã†ã‹!' : distText}</div>
        </div>
        <button class="btn-arrive ${btnClass} ${showArrive ? 'show' : ''}" data-idx="${i}">${btnText}</button>
      `;

      // å¼·åˆ¶é€šéãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆ
      const arriveBtn = li.querySelector('.btn-arrive');
      arriveBtn.addEventListener('click', e => {
        e.preventDefault();
        e.stopPropagation();
        forceArriveStation(i);
      });

      ul.appendChild(li);
    });

    $routePanel.appendChild(ul);
  }

  // ==================== å¼·åˆ¶é€šé ====================
  function forceArriveStation(idx) {
    if (!isRunning || passedStations[idx]) return;
    const isLast = idx === stations.length - 1;

    passedStations[idx] = true;

    // nextStationIndexã‚’æ›´æ–°
    while (nextStationIndex < stations.length && passedStations[nextStationIndex]) {
      nextStationIndex++;
    }
    if (nextStationIndex >= stations.length) nextStationIndex = stations.length - 1;

    if (isLast) {
      // ã‚´ãƒ¼ãƒ«
      maxProgress = 100000;
      $progressValue.textContent = '100.000';
      $progressRemaining.textContent = 'ã‚´ãƒ¼ãƒ«!';
      drawTrainBar(100000, stations.length, stations.length);
      sendProgressForced(100000, 0, 0, stations.length - 1, stations.length);
      renderRoute();
      setTimeout(() => stopTracking(), 500);
    } else {
      // ä¸­é–“é§…é€šé â€” é€²æ—ã‚’+1ã—ã¦M5å´ã®å¤‰åŒ–æ¤œçŸ¥ã‚’ç¢ºå®Ÿã«ã—ã€ç¢ºå®Ÿé€ä¿¡
      if (maxProgress < 99999) maxProgress++;
      renderRoute();
      $progressValue.textContent = (maxProgress / 1000).toFixed(3);
      drawTrainBar(maxProgress, nextStationIndex, stations.length);
      sendProgressForced(maxProgress, 0, 0, nextStationIndex, stations.length);
    }
  }

  // ==================== è¨­å®šç”»é¢ ====================
  function openSettings() {
    $settingsOverlay.classList.add('show');
    ensureGoogleMaps().then(() => {
      if (!map) initMap();
      else google.maps.event.trigger(map, 'resize');
      updateMap();
    }).catch(() => {
      // Maps APIãŒèª­ã‚ãªãã¦ã‚‚ãƒªã‚¹ãƒˆç·¨é›†ã¯ã§ãã‚‹
    });
  }

  $btnSettings.addEventListener('click', openSettings);
  $settingsClose.addEventListener('click', () => {
    $settingsOverlay.classList.remove('show');
    $searchResults.classList.remove('show');
  });

  function initMap() {
    map = new google.maps.Map($('map'), {
      center: { lat: 35.6812, lng: 139.7671 },
      zoom: 15, disableDefaultUI: true, zoomControl: true,
      styles: [
        { featureType: 'poi', elementType: 'labels', stylers: [{ visibility: 'off' }] },
        { featureType: 'transit', stylers: [{ visibility: 'off' }] }
      ]
    });
    placesService = new google.maps.places.PlacesService(map);

    // ç¾åœ¨åœ°
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(pos => {
        const loc = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        map.setCenter(loc); map.setZoom(16);
      }, () => {}, { enableHighAccuracy: true });
    }

    // åœ°å›³ã‚¿ãƒƒãƒ—ã§é§…è¿½åŠ 
    map.addListener('click', e => {
      openNameModal(e.latLng.lat(), e.latLng.lng());
    });
  }

  // ==================== è¨­å®š: é§…ãƒªã‚¹ãƒˆæç”» ====================
  function renderSettingsStations() {
    $settingsStationList.innerHTML = '';
    stations.forEach((s, i) => {
      const li = document.createElement('li');
      li.className = 'ss-item';
      const isFirst = i === 0;
      const isLast = i === stations.length - 1;

      li.innerHTML = `
        <span class="ss-num">${i + 1}</span>
        <span class="ss-name" data-id="${s.id}">${s.name}é§…${isLast ? ' <span class="ss-badge">çµ‚ç€</span>' : ''}</span>
        <div class="ss-actions">
          <button class="ss-btn" data-dir="up" ${isFirst ? 'disabled' : ''}>&#8593;</button>
          <button class="ss-btn" data-dir="down" ${isLast ? 'disabled' : ''}>&#8595;</button>
          <button class="ss-btn delete" data-del="${s.id}">&#215;</button>
        </div>
      `;

      // ä¸¦ã¹æ›¿ãˆ
      li.querySelectorAll('.ss-btn[data-dir]').forEach(btn => {
        const handler = e => {
          e.preventDefault(); e.stopPropagation();
          if (btn.disabled) return;
          moveStation(i, btn.dataset.dir === 'up' ? i - 1 : i + 1);
        };
        btn.addEventListener('click', handler);
        btn.addEventListener('touchend', handler);
      });

      // å‰Šé™¤
      const delBtn = li.querySelector('.ss-btn.delete');
      delBtn.addEventListener('click', e => {
        e.stopPropagation();
        removeStation(s.id);
      });

      // é§…åã‚¿ãƒƒãƒ—ã§ç·¨é›†
      const nameEl = li.querySelector('.ss-name');
      nameEl.addEventListener('click', () => {
        const input = document.createElement('input');
        input.className = 'ss-name-edit';
        input.value = s.name;
        input.maxLength = 6;
        nameEl.replaceWith(input);
        input.focus(); input.select();
        const finish = () => {
          const val = input.value.trim();
          if (val) renameStation(s.id, val);
          else renderAll();
        };
        input.addEventListener('blur', finish);
        input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); });
      });

      $settingsStationList.appendChild(li);
    });
  }

  $settingsAdd.addEventListener('click', () => {
    $mapHint.textContent = 'ã‚¿ãƒƒãƒ—ã—ã¦ ãˆãã‚’ ã¤ã„ã‹';
  });

  // ==================== åœ°å›³: ãƒãƒ¼ã‚«ãƒ¼ãƒ»ãƒ«ãƒ¼ãƒˆæ›´æ–° ====================
  function updateMap() {
    if (!map) return;
    stationMarkers.forEach(m => m.setMap(null));
    stationMarkers = [];
    if (routeLine) { routeLine.setMap(null); routeLine = null; }
    if (stations.length === 0) return;

    stations.forEach((s, i) => {
      const isLast = i === stations.length - 1;
      const marker = new google.maps.Marker({
        position: { lat: s.lat, lng: s.lng }, map,
        label: { text: isLast ? 'â˜…' : String(i + 1), color: '#fff', fontSize: '11px', fontWeight: 'bold' },
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: isLast ? 13 : 10,
          fillColor: isLast ? '#E63946' : '#38A169', fillOpacity: 1,
          strokeColor: '#fff', strokeWeight: 2,
        },
        title: s.name + 'é§…'
      });
      stationMarkers.push(marker);
    });

    if (stations.length >= 2) {
      routeLine = new google.maps.Polyline({
        path: stations.map(s => ({ lat: s.lat, lng: s.lng })),
        strokeColor: '#E63946', strokeOpacity: 0.7, strokeWeight: 4, geodesic: true,
        icons: [{ icon: { path: 'M 0,-1 0,1', strokeOpacity: 1, scale: 3 }, offset: '0', repeat: '15px' }]
      });
      routeLine.setMap(map);
    }

    const bounds = new google.maps.LatLngBounds();
    stations.forEach(s => bounds.extend({ lat: s.lat, lng: s.lng }));
    map.fitBounds(bounds, 40);
  }

  // ==================== é§…åãƒ¢ãƒ¼ãƒ€ãƒ« ====================
  function openNameModal(lat, lng) {
    pendingStationLatLng = { lat, lng };
    $nameInput.value = '';
    $nameInput.placeholder = stations.length === 0 ? 'ãŠã†ã¡' : 'ã“ã†ãˆã‚“';
    $nameModal.classList.add('show');
    setTimeout(() => $nameInput.focus(), 100);
  }

  $nameCancel.addEventListener('click', () => {
    $nameModal.classList.remove('show');
    pendingStationLatLng = null;
  });
  $nameOk.addEventListener('click', confirmName);
  $nameInput.addEventListener('keydown', e => { if (e.key === 'Enter') confirmName(); });

  function confirmName() {
    const name = $nameInput.value.trim();
    if (!name || !pendingStationLatLng) return;
    addStation(name, pendingStationLatLng.lat, pendingStationLatLng.lng);
    $nameModal.classList.remove('show');
    pendingStationLatLng = null;
  }

  // ==================== æ¤œç´¢ ====================
  $searchBtn.addEventListener('click', doSearch);
  $searchInput.addEventListener('keydown', e => { if (e.key === 'Enter') doSearch(); });

  function doSearch() {
    const q = $searchInput.value.trim();
    if (!q || !placesService) return;
    $searchBtn.disabled = true;
    placesService.textSearch({ query: q, language: 'ja', region: 'jp' }, (results, status) => {
      $searchBtn.disabled = false;
      $searchResults.innerHTML = '';
      if (status === google.maps.places.PlacesServiceStatus.OK && results.length) {
        results.slice(0, 5).forEach(r => {
          const item = document.createElement('div');
          item.className = 'sr-item';
          item.innerHTML = `<div class="sr-name">${r.name}</div><div class="sr-addr">${r.formatted_address || ''}</div>`;
          item.addEventListener('click', () => {
            const lat = r.geometry.location.lat(), lng = r.geometry.location.lng();
            map.setCenter({ lat, lng }); map.setZoom(16);
            $searchResults.classList.remove('show');
            $searchInput.value = '';
            openNameModal(lat, lng);
            setTimeout(() => { $nameInput.value = r.name.slice(0, 6); }, 100);
          });
          $searchResults.appendChild(item);
        });
      } else {
        $searchResults.innerHTML = '<div class="sr-item"><div class="sr-name">è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</div></div>';
      }
      const close = document.createElement('div');
      close.className = 'sr-close';
      close.textContent = 'Ã— é–‰ã˜ã‚‹';
      close.addEventListener('click', () => $searchResults.classList.remove('show'));
      $searchResults.appendChild(close);
      $searchResults.classList.add('show');
    });
  }

  // ==================== BLE ====================
  $btnBle.addEventListener('click', async () => {
    try {
      $btnBle.textContent = 'æ¥ç¶šä¸­...';
      bleDevice = await navigator.bluetooth.requestDevice({
        filters: [{ name: 'OsampoMeter' }], optionalServices: [SERVICE_UUID]
      });
      bleDevice.addEventListener('gattserverdisconnected', onBleDisconnected);
      const server = await bleDevice.gatt.connect();
      const service = await server.getPrimaryService(SERVICE_UUID);
      bleCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
      $bleBadge.textContent = 'BLEæ¥ç¶šæ¸ˆ'; $bleBadge.classList.add('connected');
      $btnBle.textContent = 'æ¥ç¶šæ¸ˆ'; $btnBle.disabled = true;
    } catch(err) {
      console.error('BLE:', err);
      $btnBle.textContent = 'BLEæ¥ç¶š';
      alert('BLEæ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  });

  function onBleDisconnected() {
    bleCharacteristic = null;
    bleDevice = null;
    $bleBadge.textContent = 'BLEæœªæ¥ç¶š'; $bleBadge.classList.remove('connected');
    $btnBle.textContent = 'BLEæ¥ç¶š'; $btnBle.disabled = false;
    if (isRunning) stopTracking();
  }

  // ==================== BLEé€ä¿¡ ====================
  // å„é§…ã®ãƒ«ãƒ¼ãƒˆä¸Šã®ä½ç½®(0-100)ã‚’è¨ˆç®—
  function calcStationProgressPcts() {
    if (stations.length === 0) return [];
    if (stations.length === 1) return [100];
    // ç´¯ç©è·é›¢ã‚’è¨ˆç®—
    const cumDist = [0];
    for (let i = 1; i < stations.length; i++) {
      cumDist.push(cumDist[i-1] + haversineDistance(
        stations[i-1].lat, stations[i-1].lng,
        stations[i].lat, stations[i].lng
      ));
    }
    const totalDist = cumDist[cumDist.length - 1];
    if (totalDist === 0) return stations.map(() => 0);
    return cumDist.map(d => Math.round((d / totalDist) * 100));
  }

  async function sendStationNames() {
    if (!bleCharacteristic) return;
    const pcts = calcStationProgressPcts();
    try {
      await bleCharacteristic.writeValueWithResponse(new Uint8Array([0x02]).buffer);
      await sleep(50);
      for (let i = 0; i < stations.length; i++) {
        const nameBytes = new TextEncoder().encode(stations[i].name + 'é§…');
        const nameLen = Math.min(nameBytes.length, 18);
        const pkt = new Uint8Array(3 + nameLen + 1); // +1 for progressPct
        pkt[0] = 0x01; pkt[1] = i; pkt[2] = nameLen;
        pkt.set(nameBytes.slice(0, nameLen), 3);
        pkt[3 + nameLen] = pcts[i] || 0;  // ä½ç½®% (0-100)
        await bleCharacteristic.writeValueWithResponse(pkt.buffer);
        await sleep(50);
      }
    } catch(err) { console.error('é§…åé€ä¿¡ã‚¨ãƒ©ãƒ¼:', err); }
  }

  async function sendProgressV2(overallProgress, distNext, distFinal, nextIdx, totalSt) {
    const clamped = Math.max(0, Math.min(100000, Math.round(overallProgress)));
    if (clamped === lastSentProgress) return;
    lastSentProgress = clamped;
    if (!bleCharacteristic) return;
    try {
      const buf = new ArrayBuffer(16);
      const v = new DataView(buf);
      v.setUint8(0, 0x00);
      v.setUint32(1, clamped, true);
      v.setUint32(5, Math.max(0, Math.round(distNext)), true);
      v.setUint32(9, Math.max(0, Math.round(distFinal)), true);
      v.setUint8(13, nextIdx); v.setUint8(14, totalSt); v.setUint8(15, 0);
      await bleCharacteristic.writeValueWithoutResponse(buf);
    } catch(err) { console.error('BLEé€ä¿¡ã‚¨ãƒ©ãƒ¼:', err); }
  }

  // å¼·åˆ¶é€šéç”¨: writeValueWithResponseã§ç¢ºå®Ÿã«é€ä¿¡
  async function sendProgressForced(overallProgress, distNext, distFinal, nextIdx, totalSt) {
    lastSentProgress = -1; // æ¬¡å›ã®é€šå¸¸é€ä¿¡ã‚‚ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„
    if (!bleCharacteristic) return;
    const clamped = Math.max(0, Math.min(100000, Math.round(overallProgress)));
    try {
      const buf = new ArrayBuffer(16);
      const v = new DataView(buf);
      v.setUint8(0, 0x00);
      v.setUint32(1, clamped, true);
      v.setUint32(5, Math.max(0, Math.round(distNext)), true);
      v.setUint32(9, Math.max(0, Math.round(distFinal)), true);
      v.setUint8(13, nextIdx); v.setUint8(14, totalSt); v.setUint8(15, 0);
      await bleCharacteristic.writeValueWithResponse(buf);
    } catch(err) { console.error('BLEå¼·åˆ¶é€ä¿¡ã‚¨ãƒ©ãƒ¼:', err); }
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  // ==================== GPSè¿½è·¡ ====================
  $btnStart.addEventListener('click', () => {
    if (isRunning) stopTracking(); else startTracking();
  });

  async function startTracking() {
    if (stations.length === 0) return;
    isRunning = true;
    startDistance = null; maxProgress = 0; lastSentProgress = -1;
    nextStationIndex = 0;
    passedStations = new Array(stations.length).fill(false);

    $btnStart.textContent = 'ã‚¹ãƒˆãƒƒãƒ—';
    $btnStart.classList.remove('btn-start'); $btnStart.classList.add('btn-stop');
    $btnSettings.style.display = 'none';
    $progressValue.textContent = '0.000';
    $progressRemaining.textContent = '';

    renderRoute();
    drawTrainBar(0, 0, stations.length);

    await requestWakeLock();
    await sendStationNames();
    sendProgressV2(0, 0, 0, 0, stations.length);

    watchId = navigator.geolocation.watchPosition(
      onPositionUpdate, err => console.error('GPS:', err),
      { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 }
    );
  }

  function stopTracking() {
    isRunning = false;
    if (watchId !== null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
    startDistance = null; maxProgress = 0;

    $btnStart.textContent = 'ã—ã‚…ã£ã±ã¤!';
    $btnStart.classList.remove('btn-stop'); $btnStart.classList.add('btn-start');
    $btnSettings.style.display = '';

    renderRoute();
    releaseWakeLock();
  }

  // ç‚¹Pã‹ã‚‰ç·šåˆ†ABä¸Šã¸ã®å°„å½±ä½ç½®(0-1)ã¨è·é›¢ã‚’è¿”ã™
  function projectOntoSegment(pLat, pLng, aLat, aLng, bLat, bLng) {
    const apLat = pLat - aLat, apLng = pLng - aLng;
    const abLat = bLat - aLat, abLng = bLng - aLng;
    const ab2 = abLat * abLat + abLng * abLng;
    if (ab2 === 0) return { t: 0, dist: haversineDistance(pLat, pLng, aLat, aLng) };
    const t = Math.max(0, Math.min(1, (apLat * abLat + apLng * abLng) / ab2));
    const projLat = aLat + t * abLat, projLng = aLng + t * abLng;
    return { t, dist: haversineDistance(pLat, pLng, projLat, projLng) };
  }

  // ç´¯ç©è·é›¢ãƒ™ãƒ¼ã‚¹ã®é€²æ—è¨ˆç®—
  function calcRouteProgress(lat, lng) {
    if (stations.length < 2) return { progress: 0, distToFinal: 0, distToNext: 0 };

    // å„åŒºé–“ã®è·é›¢ã¨ç´¯ç©è·é›¢
    const segDists = [];
    const cumDist = [0];
    for (let i = 1; i < stations.length; i++) {
      const d = haversineDistance(stations[i-1].lat, stations[i-1].lng, stations[i].lat, stations[i].lng);
      segDists.push(d);
      cumDist.push(cumDist[i-1] + d);
    }
    const totalDist = cumDist[cumDist.length - 1];
    if (totalDist === 0) return { progress: 0, distToFinal: 0, distToNext: 0 };

    // å…¨åŒºé–“ã¸ã®å°„å½±ã§æœ€ã‚‚è¿‘ã„å ´æ‰€ã‚’è¦‹ã¤ã‘ã‚‹
    let bestDist = Infinity, bestCum = 0;
    for (let i = 0; i < stations.length - 1; i++) {
      const proj = projectOntoSegment(lat, lng,
        stations[i].lat, stations[i].lng,
        stations[i+1].lat, stations[i+1].lng);
      if (proj.dist < bestDist) {
        bestDist = proj.dist;
        bestCum = cumDist[i] + proj.t * segDists[i];
      }
    }

    const progress = (bestCum / totalDist) * 100000;
    const distToFinal = haversineDistance(lat, lng, stations[stations.length-1].lat, stations[stations.length-1].lng);
    const nextSt = stations[Math.min(nextStationIndex, stations.length - 1)];
    const distToNext = haversineDistance(lat, lng, nextSt.lat, nextSt.lng);

    return { progress: Math.max(0, Math.min(99999, progress)), distToFinal, distToNext };
  }

  function onPositionUpdate(pos) {
    const lat = pos.coords.latitude, lng = pos.coords.longitude;

    const finalStation = stations[stations.length - 1];
    const distToFinal = haversineDistance(lat, lng, finalStation.lat, finalStation.lng);

    // é§…é€šéãƒã‚§ãƒƒã‚¯
    for (let i = nextStationIndex; i < stations.length; i++) {
      const d = haversineDistance(lat, lng, stations[i].lat, stations[i].lng);
      const radius = (i === stations.length - 1) ? GOAL_RADIUS : STATION_ARRIVAL_RADIUS;
      if (d <= radius && !passedStations[i]) {
        passedStations[i] = true;
        if (i === nextStationIndex) {
          nextStationIndex = Math.min(i + 1, stations.length - 1);
        }
        renderRoute();
      }
    }

    let progress;
    let distToNext;
    if (distToFinal <= GOAL_RADIUS) {
      progress = 100000;
      distToNext = 0;
    } else {
      const rp = calcRouteProgress(lat, lng);
      progress = rp.progress;
      distToNext = rp.distToNext;
    }

    let progressRounded = Math.round(progress);
    if (progressRounded < maxProgress) progressRounded = maxProgress;
    else maxProgress = progressRounded;

    $progressValue.textContent = (progressRounded / 1000).toFixed(3);
    $progressRemaining.textContent = 'ã‚´ãƒ¼ãƒ«ã¾ã§ ' + formatDist(distToFinal);
    drawTrainBar(progressRounded, nextStationIndex, stations.length);
    sendProgressV2(progressRounded, distToNext, distToFinal, nextStationIndex, stations.length);
  }

  // ==================== ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ ====================
  let testTimer = null, testProgress = 0;

  $btnTest.addEventListener('click', () => {
    if (testMode) {
      testMode = false;
      if (testTimer) { clearInterval(testTimer); testTimer = null; }
      testProgress = 0;
      $btnTest.classList.remove('active');
      $bleBadge.textContent = bleCharacteristic ? 'BLEæ¥ç¶šæ¸ˆ' : 'BLEæœªæ¥ç¶š';
      $bleBadge.classList.remove('test-mode');
      $progressValue.textContent = '0.000';
      $progressRemaining.textContent = '';
      isRunning = false;
      passedStations = [];
      nextStationIndex = 0;
      $btnSettings.style.display = '';
      renderRoute();
      drawTrainBar(0, 0, Math.max(1, stations.length));
      releaseWakeLock();
    } else {
      testMode = true; isRunning = true;
      testProgress = 0;
      nextStationIndex = 0;
      passedStations = new Array(stations.length).fill(false);
      $btnTest.classList.add('active');
      $bleBadge.textContent = 'ãƒ†ã‚¹ãƒˆ'; $bleBadge.classList.add('test-mode');
      $btnSettings.style.display = 'none';
      renderRoute();
      requestWakeLock();
      sendStationNames();

      const total = Math.max(1, stations.length);
      testTimer = setInterval(() => {
        testProgress += 167;
        if (testProgress > 100000) testProgress = 100000;
        const fakeSt = Math.floor((testProgress / 100000) * total);

        // é€šéæ¸ˆã¿ã®é§…ã‚’æ›´æ–°
        for (let i = 0; i < fakeSt && i < stations.length; i++) {
          if (!passedStations[i]) {
            passedStations[i] = true;
            renderRoute();
          }
        }
        nextStationIndex = Math.min(fakeSt, stations.length - 1);

        $progressValue.textContent = (testProgress / 1000).toFixed(3);
        $progressRemaining.textContent = 'ãƒ†ã‚¹ãƒˆä¸­...';
        drawTrainBar(testProgress, fakeSt, total);
        sendProgressV2(testProgress, 100, 500, Math.min(fakeSt, total - 1), total);
        if (testProgress >= 100000) { clearInterval(testTimer); testTimer = null; }
      }, 100);
    }
  });

  // ==================== é›»è»Šãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ ====================
  function drawTrainBar(progress, nextIdx, totalStations) {
    const canvas = trainCanvas;
    const dpr = window.devicePixelRatio || 1;
    const W = canvas.clientWidth, H = canvas.clientHeight;
    if (W === 0 || H === 0) return;
    canvas.width = W * dpr; canvas.height = H * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);

    const padX = 16, trackY = H / 2 + 2, trackW = W - 2 * padX;

    // æ•æœ¨
    ctx.strokeStyle = '#E2E8F0'; ctx.lineWidth = 1;
    for (let x = padX; x <= padX + trackW; x += 8) {
      ctx.beginPath(); ctx.moveTo(x, trackY - 5); ctx.lineTo(x, trackY + 5); ctx.stroke();
    }
    // ãƒ¬ãƒ¼ãƒ«
    ctx.strokeStyle = '#A0AEC0'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(padX, trackY - 3); ctx.lineTo(padX + trackW, trackY - 3); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX, trackY + 3); ctx.lineTo(padX + trackW, trackY + 3); ctx.stroke();

    // é§…ãƒãƒ¼ã‚«ãƒ¼ï¼ˆå®Ÿéš›ã®ä½ç½®ã«é…ç½®ï¼‰
    const pcts = calcStationProgressPcts();
    const hasPositionData = pcts.length >= 2 && pcts[pcts.length - 1] === 100;
    for (let i = 0; i < totalStations; i++) {
      let x;
      if (hasPositionData && pcts[i] !== undefined) {
        x = padX + (trackW * pcts[i]) / 100;
      } else {
        x = padX + (trackW * (i + 1)) / (totalStations + 1);
      }
      const isLast = i === totalStations - 1;
      ctx.beginPath(); ctx.arc(x, trackY, isLast ? 7 : 5.5, 0, Math.PI * 2);
      if (i < nextIdx) { ctx.fillStyle = '#38A169'; ctx.fill(); }
      else if (isLast) { ctx.fillStyle = '#E63946'; ctx.fill(); }
      else { ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle = '#A0AEC0'; ctx.lineWidth = 1.5; ctx.stroke(); }
    }

    // é›»è»Š
    const trainX = padX + (trackW * Math.min(progress, 100000)) / 100000;
    ctx.fillStyle = '#E63946';
    ctx.beginPath(); ctx.roundRect(trainX - 9, trackY - 16, 18, 12, 2); ctx.fill();
    ctx.fillStyle = '#FFF5F5';
    ctx.fillRect(trainX - 6, trackY - 14, 4, 4);
    ctx.fillRect(trainX + 2, trackY - 14, 4, 4);
    ctx.fillStyle = '#fff';
    ctx.fillRect(trainX - 9, trackY - 6, 18, 1.5);
  }

  // ==================== Wake Lock ====================
  async function requestWakeLock() {
    try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch(e) {}
  }
  function releaseWakeLock() { if (wakeLock) { wakeLock.release(); wakeLock = null; } }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && (isRunning || testMode)) requestWakeLock();
  });

  // ==================== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====================
  function haversineDistance(lat1, lng1, lat2, lng2) {
    const R = 6371000, toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1), dLng = toRad(lng2 - lng1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
  function formatDist(m) { return m >= 1000 ? (m/1000).toFixed(1) + ' km' : Math.round(m) + ' m'; }
  function updateStartButton() { $btnStart.disabled = stations.length === 0; }

  // ==================== åˆæœŸåŒ– ====================
  loadStations();
  renderAll();
  drawTrainBar(0, 0, Math.max(1, stations.length));
}
</script>
</body>
</html>
